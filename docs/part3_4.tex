
\chapter{Code emit}

The code emit process is the final process of the compiler whereby
the \texttt{initQueue}, \texttt{codeQueue} and all assorted auxilllary
information is passed to an instance of \texttt{CodeEmitter} (in
the case of the C backend this is sub-typed to the \texttt{DGen}
class) such that the code can be written to a file. At this stage
all queues consist simply of instances of the \texttt{Instruction}
class.\\
\\
Our C backend or \emph{custom code emitter}, \texttt{DGen}, inherits
from the \texttt{CodeEmitter} class which specifies that the following
methods must be overriden/implemented:
\begin{enumerate}
\item \texttt{emit()}
\begin{enumerate}
\item Begins the emit process
\end{enumerate}
\item \texttt{finalize()}
\begin{enumerate}
\item Finalizes the emitting process (only to be called after the `emit()`
finishes)
\end{enumerate}
\item \texttt{transform(Instruction instruction)}
\begin{enumerate}
\item Transforms or emits a single Instruction and returns the transformation
as a string
\end{enumerate}
\end{enumerate}

\section{Queues}

There are several notable queues that the \texttt{CodeEmitter} class
contains, these are as follows:
\begin{enumerate}
\item \texttt{initQueue}
\begin{enumerate}
\item Despite its name this holds instructions for doing memory allocations
for static entities (\textbf{not} initialization code for said entities)
\end{enumerate}
\item \texttt{globalsQueue}
\begin{enumerate}
\item This queue holds instructions for the globals executions. This includes
things such as global variable declarations and the sorts.
\end{enumerate}
\item Function definitions map
\begin{enumerate}
\item This is a string-to-queue map which contains the code queues for every
function definition.
\end{enumerate}
\end{enumerate}
~\\
Along with these queues there are some methods used to amniopulate
and use them, these are:
\begin{enumerate}
\item \texttt{selectQueue(QueueType, string)}
\begin{enumerate}
\item Select the type of queue: \texttt{ALLOC\_QUEUE} (for the \texttt{initQueue}),
\texttt{GLOBALS\_QUEUE} (for \texttt{globalsQueue} and \texttt{FUNCTION\_DEF\_QUEUE}
(for the function definitions queue)
\item For function definitions, the optional string argument (second argument)
must specify the name of the function definition you would wish to
use. An invalid name will throw an error.
\item This automatically calls \texttt{resetCursor()}.
\end{enumerate}
\item \texttt{nextInstruction()}
\begin{enumerate}
\item Moves the cursor to the next instruction. Throws an exception if out
of bounds.
\end{enumerate}
\item \texttt{previousInstruction()}
\begin{enumerate}
\item Moves the cursor to the previous instruction. Throws an exception
if out of bounds.
\end{enumerate}
\item \texttt{resetCursor()}
\begin{enumerate}
\item Resets the position of the instruction pointer to 0.
\end{enumerate}
\item \texttt{getCurrentInstruction()}
\begin{enumerate}
\item Retrieves the current instruction at the cursor.
\end{enumerate}
\end{enumerate}

\section{Custom code emits}

We override/implement the \texttt{transform(Instruction instruction)}
in \texttt{DGen} to work somewhat as a big if-statement that matches
the different sub-types of Instructions that exist, then the respective
code-emit (C code) is generated. This method has the potential to
be recursive as some instructions contain nested instructions that
must be transformed prior before the final transformation, in which
case a recursive call to \texttt{transform(Instruction)} is made.

\subsection{Code emit example: Variable declarations}

The example below is the code used to transform the in-memory representation
of a variable declaration, known as the \texttt{VariableDeclaration}
instruction, into the C code to be emitted:\\
\\
\begin{lstlisting}[language=Java]
/* VariableDeclaration */
else if(cast(VariableDeclaration)instruction)
{
	VariableDeclaration varDecInstr = cast(VariableDeclaration)instruction;
	Context context = varDecInstr.getContext();
	
	Variable typedEntityVariable = cast(Variable)context.tc.getResolver().resolveBest(context.getContainer(), varDecInstr.varName);

	string renamedSymbol = SymbolMapper.symbolLookup(typedEntityVariable);

	return varDecInstr.varType~" "~renamedSymbol~";";
}
\end{lstlisting}What we have here is some code which will extract the name of the
variable being declared via \textbackslash texttt\{varDecInstr.varName\}
which is then used to lookup the parser node of type \texttt{Variable}.
The \texttt{Variable} object contains information such as the variable's
type and also if a variable assignment is attached to this declaration
or not.\\
\\
TODO: Insert code regarding assignment checking\\
\\
Right at the end wwe then build up the C variable declaration with
the line:\begin{lstlisting}[language=Java]
return varDecInstr.varType~" "~renamedSymbol~";";
\end{lstlisting}

\subsection{Symbol renaming}

In terms of general code emitting we could have simply decided to
use the TLang-esque symbol name structure where entities are seperated
by periods such as \texttt{simple\_module.x} where \texttt{simple\_module}
is a container-type such as a \texttt{module} and \texttt{x} is
some entity within it, such as a variable. However, what we have decided
to do in the emitter process, specifically in \texttt{DGen} - our
C code emitter - is to actually rename these symbols to a hash, wherever
they occur.\\
\\
The renaming mechanism is hanlded by the \texttt{symbolLookup(Entity)}
method from the \texttt{SymbolMapper} class. This method takes in
a single argument:
\begin{enumerate}
\item \texttt{entity}
\begin{enumerate}
\item This must be a type-of \texttt{Entity}, this is the entity of which
the symbol renaming should be applied on.
\end{enumerate}
\end{enumerate}
~\\
This allows one do then translate the symbol name with the following
usage. In this case we want to translate the symbol of the entity
named \texttt{x} which is container in the module-container named
\texttt{simple\_variables\_decls\_ass}. Therefore we provide both
peices of information into the function \texttt{symbolLookup}:\begin{lstlisting}[language=Java]
// The relative container of this variable is the module
Container container = tc.getModule();

// Lookup a variable named "x"
string varLookup = "x"

// The Variable (type-of Entity)
Variable variable = cast(Variable)tc.getResolver().resolveBest(context.getContainer(), varLookup);

// Symbol map
string renamedSymbol = SymbolMapper.symbolLookup(variable);

// renamedSymbol == t_c326f89096616e69e89a3874a4c7f324
\end{lstlisting}~\\
The resulting hash is generated by resolving the absolute path name
of the entity provided, applying an md5 hash to this name and then
pre-pending a \texttt{t\_} to the name. Therefore for the above code
we will have \texttt{simple\_variables\_decls\_ass.x} mapped to a
symbol name of \texttt{t\_c326f89096616e69e89a3874a4c7f324} to be
emitted into the C code file.
