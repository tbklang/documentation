#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Aims
\end_layout

\begin_layout Standard
A programming language normally has an aim, a 
\emph on
purpose of existence
\emph default
, to put it in a snobbish way that a white male like me would.
 It can range from solving a problem in a highly specific domain (such are
 Domain Specific Language (TODO: add citation)) to trying to solving various
 problems spread across several different domains, a 
\emph on
general purpose
\emph default
 programming language.
 This is where I would like to place Tristan - a language that can support
 multiple paradigms of programming - whether this be object-oriented programming
 with the usage of 
\emph on
classes
\emph default
 and 
\emph on
objects
\emph default
 or functional programming with techniques such as map and filter.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Tristan aims to be able to support all of these but with certain limits,
 this is after all mainly an imperative language with those paradigms as
 
\emph on

\begin_inset Quotes eld
\end_inset

extra features
\begin_inset Quotes erd
\end_inset


\emph default
.
 Avoiding feature creep in other systems-levels languages such as C++ is
 something I really want to stress about the design of this language, I
 do not want a big and confusing mess that has an extremely steep learning
 curve and way too many moving parts.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

One should not require the knowledge of more than two different paradigms
 in order to understand the usage of a standard library function as an example.
 If a user is looking at the documentation of a given function call then
 at most the amount of concepts required to understand it should be two,
 for example a 
\emph on
templatised
\emph default
 and 
\emph on
object-based
\emph default
 function would be the upper bound on concepts allowed.
\end_layout

\begin_layout Section
Features
\end_layout

\begin_layout Standard
Tristan is a procedural programming language that supports object-oriented
 programming and templates.
\end_layout

\begin_layout Subsection
Object-oriented programming
\end_layout

\begin_layout Standard
Object orientation allows the programmer to create user-defined types which
 encapsulate both data fields and methods which act upon said data.
 Tristan supports:
\end_layout

\begin_layout Enumerate
Class-based object orientation
\end_layout

\begin_deeper
\begin_layout Enumerate
Classes as the base of user-defined types and objects are instances of these
 types
\end_layout

\begin_layout Enumerate
Single inheritance hierachy
\end_layout

\begin_layout Enumerate
Runtime polymorhpism
\end_layout

\end_deeper
\begin_layout Enumerate
Interfaces
\end_layout

\begin_deeper
\begin_layout Enumerate
Multiple inheritance
\end_layout

\begin_layout Enumerate
Runtime polomprhism (thinking
\backslash
hyperref{})
\end_layout

\end_deeper
\begin_layout Standard
It is with this lean approach to object orientation that we keep things
 simple enough (only single inheritance) but with enough power to model
 the real world in code (by supporting interfaces).
\end_layout

\begin_layout Section
Granularity of control
\end_layout

\begin_layout Standard
TODO: Add this, such as register control etc
\end_layout

\begin_layout Section
Weak typing
\end_layout

\begin_layout Standard
TODO: Let you do what you want
\end_layout

\begin_layout Section
Systems-level
\end_layout

\begin_layout Standard
Tristan does not shy away from features which give you access to system-level
 concepts such as memory addresses (via pointers), assembly (via the inline
 assembler) and so on.
 Such features are inherently unsafe but it is this sort of control that
 I wish to give the user, the balance between what the compiler should do
 and what the user should make sure they are doing is tipped quite heavily
 in favor of the latter in my viewpoint and hence we support such features
 as:
\end_layout

\begin_layout Itemize
Weak typing
\end_layout

\begin_deeper
\begin_layout Itemize
By default this is not the behavior when using 
\backslash
texttt{cast()}
\end_layout

\begin_layout Itemize
Casting to an incompatible type is allowed - even when a runtime-type check
 is invalid you can still force a cast with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{castunsafe()}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The user should be able to do what 
\emph on
he
\emph default
 wants if requested
\end_layout

\end_deeper
\begin_layout Itemize
Pointers
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
TODO:
\series default
 Expand on this
\end_layout

\begin_layout Itemize
The mere 
\emph on
support
\emph default
 of pointers allowing one to take a memory-level view of objects in memory
 rather than the normal 
\begin_inset Quotes eld
\end_inset

safe access
\begin_inset Quotes erd
\end_inset

 means
\end_layout

\end_deeper
\begin_layout Itemize
Inline assembly
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
TODO:
\series default
 Expand on this
\end_layout

\begin_layout Itemize
Inserting of arbitrary assembler is allowed, providing the programmer with
 access to systems level registers, interrupts/syscall instructions and
 so on
\end_layout

\end_deeper
\begin_layout Itemize
Custom byte-packing
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
TODO:
\series default
 How will we go about this in the backend C compiler
\end_layout

\begin_layout Itemize
Allowing the user to deviate from the normal struct packing structure in
 favor of a tweaked packing technique
\end_layout

\begin_layout Itemize
Custom packing on a system that doesn't agree with the alignment of your
 data 
\series bold
is 
\series default
allowed but the default is to pack accordingly to the respective platform
\end_layout

\end_deeper
\end_body
\end_document
