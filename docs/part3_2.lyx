#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Parsing
\end_layout

\begin_layout Standard
Once we have generated a list of tokens (instances of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token}
\end_layout

\end_inset

) from the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Lexer}
\end_layout

\end_inset

 instance we need to turn these into a structure that represents our program's
 source code 
\emph on
but
\series bold
\emph default
 
\series default
using in-memory data-structures which we can traverse and process at a later
 stage.
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Parser}
\end_layout

\end_inset

 class contains several methods for parsing different sub-structures of
 a TLang program and returning different data types generated by these methods.
 The parser has the ability to move back and forth between the token stream
 provided and fetch the current token (along with analysing it to return
 the type of symbol the token represents - known as the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{SymbolType}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Cite the 
\begin_inset Quotes eld
\end_inset

Symbol types
\begin_inset Quotes erd
\end_inset

 section
\end_layout

\end_inset

).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

For example, the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{parseIf()}
\end_layout

\end_inset

 is used to parse if statements, it is called on the occurence of the token
 of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{if}
\end_layout

\end_inset

.
 This method returns an instance of type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{IfStatement}
\end_layout

\end_inset

.
 Then there are methods like 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{parseBody()}
\end_layout

\end_inset

 which is responsible for creating several sub-calls to methods such as
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{parseIf()}
\end_layout

\end_inset

 and building up a list of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Statement}
\end_layout

\end_inset

 instances (the top-type for all parser nodes).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The entry point to call is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{parse()}
\end_layout

\end_inset

 which will return an instance of type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Module}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
API
\end_layout

\begin_layout Standard
The API exposed by the parser is rather minimal as there isn't much to a
 parser than controlling the token stream pointer (the position in the token
 stream), fetching the token and acting upon the type or value of said token.
 Therefore we have the methods summarised below:
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{nextToken()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Moves the token pointer to the next token
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{previousToken()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Moves the token pointer to the previous token
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{getCurrentToken()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Returns the current 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token}
\end_layout

\end_inset

 instance at the current token pointer position
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{hasTokens()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 if there are tokens still left in the stream (i.e.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{tokenPtr < tokens.length}
\end_layout

\end_inset

), 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

 otherwise
\end_layout

\end_deeper
\begin_layout Section
Initialization
\end_layout

\begin_layout Standard
The initialization of the parser is rather simple, an instance of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Parser}
\end_layout

\end_inset

 class must be instantiated, along with this the following arguments must
 be provided to the constructor:
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token[] tokens}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
This is an array of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token}
\end_layout

\end_inset

 to be provided to the parser for parsing.
 This would have been derived from the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Lexer}
\end_layout

\end_inset

 via its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{performLex()}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{getTokens()}
\end_layout

\end_inset

 call.
\end_layout

\end_deeper
\begin_layout Standard
A new instance woud therefore be created with something akin to:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Java]
\end_layout

\begin_layout Plain Layout

// Tokenize the following program
\end_layout

\begin_layout Plain Layout

string sourceCode = 
\begin_inset Quotes eld
\end_inset

int i = 2;
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

Lexer lexer = new Lexer(sourceCode);
\end_layout

\begin_layout Plain Layout

lexer.performLex();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Extract tokens and pass to the lexer
\end_layout

\begin_layout Plain Layout

Token[] tokens = lexer.getTokens();
\end_layout

\begin_layout Plain Layout

Parser parser = new Parser(tokens);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Symbol types
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Make citable
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The stoken stream is effectively a list of instances of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token}
\end_layout

\end_inset

 which consist just of the token itself as a string and the coordinates
 of the token (where it occurs).
 However, some tokens, despite being different strings, can be of the same
 type or 
\emph on
syntactical grouping
\emph default
.
 For example one would agree that both tokens 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{1.5}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{25.2}
\end_layout

\end_inset

 are both different tokens but are both floating points.
 This is where the notion of symbol types comes in.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The enum 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{SymbolType}
\end_layout

\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{parsing/symbols/check.d}
\end_layout

\end_inset

 describes all of the available 
\emph on
types 
\emph default
of tokens there are in the grammar of the Tristan programming language like
 so:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Java]
\end_layout

\begin_layout Plain Layout

public enum SymbolType {
\end_layout

\begin_layout Plain Layout

	LE_SYMBOL,
\end_layout

\begin_layout Plain Layout

	IDENT_TYPE,
\end_layout

\begin_layout Plain Layout

	NUMBER_LITERAL,
\end_layout

\begin_layout Plain Layout

	CHARACTER_LITERAL,
\end_layout

\begin_layout Plain Layout

	STRING_LITERAL,
\end_layout

\begin_layout Plain Layout

	SEMICOLON,
\end_layout

\begin_layout Plain Layout

	LBRACE,
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
