
\chapter{Aims}

A programming language normally has an aim, a \emph{purpose of existence},
to put it in a snobbish way that a white male like me would. It can
range from solving a problem in a highly specific domain (such are
Domain Specific Language (TODO: add citation)) to trying to solving
various problems spread across several different domains, a \emph{general
purpose} programming language. This is where I would like to place
Tristan - a language that can support multiple paradigms of programming
- whether this be object-oriented programming with the usage of \emph{classes}
and \emph{objects} or functional programming with techniques such
as map and filter.\\
\\
Tristan aims to be able to support all of these but with certain limits,
this is after all mainly an imperative language with those paradigms
as \emph{``extra features''}. Avoiding feature creep in other systems-levels
languages such as C++ is something I really want to stress about the
design of this language, I do not want a big and confusing mess that
has an extremely steep learning curve and way too many moving parts.\\
\\
One should not require the knowledge of more than two different paradigms
in order to understand the usage of a standard library function as
an example. If a user is looking at the documentation of a given function
call then at most the amount of concepts required to understand it
should be two, for example a \emph{templatised} and \emph{object-based}
function would be the upper bound on concepts allowed.

\section{Paradigms}

Tristan is a procedural programming language that supports object-oriented
programming and templates.

\subsection{Object-oriented programming}

Object orientation allows the programmer to create user-defined types
which encapsulate both data fields and methods which act upon said
data. Tristan supports:
\begin{enumerate}
\item Class-based object orientation
\begin{enumerate}
\item Classes as the base of user-defined types and objects are instances
of these types
\item Single inheritance hierachy
\item Runtime polymorhpism
\end{enumerate}
\item Interfaces
\begin{enumerate}
\item Multiple inheritance
\item Runtime polomprhism (thinking\textbackslash hyperref\{\})
\end{enumerate}
\end{enumerate}
It is with this lean approach to object orientation that we keep things
simple enough (only single inheritance) but with enough power to model
the real world in code (by supporting interfaces).

\subsection{Templating}

Templating, otherwise known as \emph{generics}, is a mechanism by
which a given body of code which contains a type specifier such as
variable declarations or function definitions can have their said
type specifiers parameterized. The usage of this can be illustrated
in the code below, where we want to define a method \texttt{sum(a, b)}
which returns the summation of the two inputs. We define version that
works for integral types (\texttt{int}) and a version that works
for decimal types (\texttt{float}):\\
\begin{lstlisting}[language=C]
// Integral summation function
int sum(int a, int b)
{
	return a+b;
}

// Decimal summation function
float sum(float a, float b)
{
	return a+b;
}
\end{lstlisting}Being a small example we can reason about the easiness of simply defining
two versions of the \texttt{sum(a, b)} method for the two types,
but after some time this can either get overly repetitive if we have
to do this for more methods of a similar structure \emph{or }when
more types are involved. This is where templating comes in, we can
write a more general version of the same function and let the compiler
generate the differently typed versions dependent on what \emph{type
parameter} we pass in.\\
\\
A templatised version of the above \texttt{sum(a, b)} function is
shown below:\\
\begin{lstlisting}[language=C]
// Templatised function
template T
{
	T sum(T a, T b)
	{
		return a+b;
	}
}

// Integral version
sum!(int)(1,2)

// Decimal version
sum!(float)(1.0,2.0)
\end{lstlisting}The way this works is that whenever you call the function \texttt{sum(a, b)}
you will have to provide it with the specific type you want generated
for that function.

\section{Systems-level access}

Tristan does not shy away from features which give you access to system-level
concepts such as memory addresses (via pointers), assembly (via the
inline assembler) and so on. Such features are inherently unsafe but
it is this sort of control that I wish to give the user, the balance
between what the compiler should do and what the user should make
sure they are doing is tipped quite heavily in favor of the latter
in my viewpoint and hence we support such features as:
\begin{itemize}
\item Weak typing
\begin{itemize}
\item By default this is not the behavior when using \texttt{cast()}
\item Casting to an incompatible type is allowed - even when a run-time
type-check is invalid you can still force a cast with \texttt{castunsafe()}
\item The user should be able to do what \emph{he} wants if requested
\end{itemize}
\item Pointers
\begin{itemize}
\item The mere \emph{support} of pointers allowing one to take a memory-level
view of objects in memory rather than the normal ``safe access''
means
\end{itemize}
\item Inline assembly
\begin{itemize}
\item Inserting of arbitrary assembler is allowed, providing the programmer
with access to systems level registers, interrupts/syscall instructions
and so on
\end{itemize}
\item Custom byte-packing
\begin{itemize}
\item Allowing the user to deviate from the normal struct packing structure
in favor of a tweaked packing technique
\item Custom packing on a system that doesn't agree with the alignment of
your data \textbf{is }allowed but the default is to pack accordingly
to the respective platform
\end{itemize}
\end{itemize}

\section{Specified behaviour}

TODO: Insert ramblings here about underspecified behaviour and how
they plague C and how we easily fix this in tlang
