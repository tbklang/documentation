
\chapter{Parsing}

Once we have generated a list of tokens (instances of \texttt{Token})
from the \texttt{Lexer} instance we need to turn these into a structure
that represents our program's source code \emph{but}\textbf{ }using
in-memory data-structures which we can traverse and process at a later
stage.

\section{Overview}

The \texttt{Parser} class contains several methods for parsing different
sub-structures of a TLang program and returning different data types
generated by these methods. The parser has the ability to move back
and forth between the token stream provided and fetch the current
token (along with analysing it to return the type of symbol the token
represents - known as the \texttt{SymbolType}).\\
\\
For example, the method \texttt{parseIf()} is used to parse if statements,
it is called on the occurence of the token of \texttt{if}. This method
returns an instance of type \texttt{IfStatement}. Then there are
methods like \texttt{parseBody()} which is responsible for creating
several sub-calls to methods such as \texttt{parseIf()} and building
up a list of \texttt{Statement} instances (the top-type for all parser
nodes).\\
\\
The entry point to call is \texttt{parse()} which will return an
instance of type \texttt{Module}.

\section{API}

The API exposed by the parser is rather minimal as there isn't much
to a parser than controlling the token stream pointer (the position
in the token stream), fetching the token and acting upon the type
or value of said token. Therefore we have the methods summarised below:
\begin{enumerate}
\item \texttt{nextToken()}
\begin{enumerate}
\item Moves the token pointer to the next token
\end{enumerate}
\item \texttt{previousToken()}
\begin{enumerate}
\item Moves the token pointer to the previous token
\end{enumerate}
\item \texttt{getCurrentToken()}
\begin{enumerate}
\item Returns the current \texttt{Token} instance at the current token
pointer position
\end{enumerate}
\item \texttt{hasTokens()}
\begin{enumerate}
\item Returns \texttt{true} if there are tokens still left in the stream
(i.e. \texttt{tokenPtr < tokens.length}), \texttt{false} otherwise
\end{enumerate}
\end{enumerate}

\section{Initialization}

The initialization of the parser is rather simple, an instance of
the \texttt{Parser} class must be instantiated, along with this the
following arguments must be provided to the constructor:
\begin{enumerate}
\item \texttt{Token[] tokens}
\begin{enumerate}
\item This is an array of \texttt{Token} to be provided to the parser for
parsing. This would have been derived from the \texttt{Lexer} via
its \texttt{performLex()} and \texttt{getTokens()} call.
\end{enumerate}
\end{enumerate}
A new instance woud therefore be created with something akin to:\begin{lstlisting}[language=Java]
// Tokenize the following program
string sourceCode = "int i = 2;"
Lexer lexer = new Lexer(sourceCode);
lexer.performLex();

// Extract tokens and pass to the lexer
Token[] tokens = lexer.getTokens();
Parser parser = new Parser(tokens);
\end{lstlisting}

\section{Symbol types}

The token stream is effectively a list of instances of \texttt{Token}
which consist just of the token itself as a string and the coordinates
of the token (where it occurs). However, some tokens, despite being
different strings, can be of the same type or \emph{syntactical grouping}.
For example one would agree that both tokens \texttt{1.5} and \texttt{25.2}
are both different tokens but are both floating points. This is where
the notion of symbol types comes in.\\
\\
The enum \texttt{SymbolType} in \texttt{parsing/symbols/check.d}
describes all of the available \emph{types }of tokens there are in
the grammar of the Tristan programming language like so:\begin{lstlisting}[language=Java]
public enum SymbolType {
	LE_SYMBOL,
	IDENT_TYPE,
	NUMBER_LITERAL,
	CHARACTER_LITERAL,
	STRING_LITERAL,
	SEMICOLON,
	LBRACE,
	...
}
\end{lstlisting}~\\
Given an instance of \texttt{Token} one can pass it to the \texttt{getSymbolType(Token)}
method which will then return an enum member from \texttt{SymbolType}.
When a token has no associated symbol type then \texttt{SymbolType.UNKNOWN}
is returned. Now for an example:\begin{lstlisting}[language=Java]
// Create a new token at with (0, 0) as coordinates
Token token = new Token("100", 0, 0);

// Get the symbol type
SymbolType symType = getSymbolType(token);
assert(symType == SymbolType.NUMBER_LITERAL);
\end{lstlisting}This assertion would pass as the symbol type of such a token is a
number literal.

\subsection{API}

The API for working with and using \texttt{SymbolType}s is made available
within the \texttt{parsing/data/check.d} and contains the following
methods:
\begin{enumerate}
\item \texttt{isType(string)}
\begin{enumerate}
\item Returns \texttt{true} if the given string (a token) is a built-in
type
\item Built-in type strings would be: \texttt{byte, ubyte, short, ushort, int, uint, long, ulong, void}
\end{enumerate}
\item \texttt{getSymbolType(Token)}
\begin{enumerate}
\item Returns the \texttt{SymbolType} associated with the given \texttt{Token}
\item If the token is not of a valid type then \texttt{SymbolType.UNKNOWN}
is returned
\end{enumerate}
\item \texttt{getCharacter(SymbolType)}
\begin{enumerate}
\item This performs the reverse of \texttt{getSymbolType(Token)} in the
sense that you provide it a \texttt{SymbolType} and it will return
the corresponding string that is of that type.
\item This will work only for back-mapping a sub-section of tokens as you
won't get anything back if you provide \texttt{SymbolType.IDENT\_TYPE}
as there are infinite possibiltiies for that - not a fixed token.
\end{enumerate}
\end{enumerate}

\section{Data types}

Every node returned by a \texttt{parseX()} is of a certain type and
there are some important types to mention here. The following types
are from either \texttt{parsing/data.d} or \texttt{parsing/containers.d}.

\subsection{\texttt{Statement}}

The \texttt{Statement} type is the top-type for most parse nodes,
it has the following important methods and fields:
\begin{enumerate}
\item \texttt{weight}
\begin{enumerate}
\item This holds a \texttt{byte} value which is used for when statements
are required to be re-ordered. It starts default at 0 whereby that
is the most prioritized re-ordering value (i.e. smaller means you
appear first)
\end{enumerate}
\item \texttt{parentOf()}
\begin{enumerate}
\item This returns an instance of \texttt{Container}, specifically indicating
of which container this Statement is a \emph{parent of}.
\item It can be \texttt{null} if this Statement was not parented.
\end{enumerate}
\item \texttt{parentTo(Container)}
\begin{enumerate}
\item Set the parenting \texttt{Container} of this Statement to the one
provided.
\end{enumerate}
\item \texttt{toString()}
\begin{enumerate}
\item The default string representtion method for Statements (unless overridden)
is to show a rolling count which is increment with every instantiation
of a Statement object.
\end{enumerate}
\end{enumerate}

\subsection{\texttt{Entity}}

The \texttt{Entity} type is a sub-type of \texttt{Statement} and
represents any named entity, along with initialization scopes  and
accessor types. The following methods and fields are to note:
\begin{enumerate}
\item \texttt{this(string)}
\begin{enumerate}
\item Constructs a new instance of an Entity with the provided name.
\end{enumerate}
\item \texttt{getName()}
\begin{enumerate}
\item Returns the name of the entity.
\end{enumerate}
\item \texttt{setAccessorType(AccessorType accessorType)}
\begin{enumerate}
\item TODO: Describe this
\end{enumerate}
\item \texttt{getAccessorType()}
\begin{enumerate}
\item TODO: Describe this
\end{enumerate}
\item \texttt{setModifierType(InitScope initScope)}
\begin{enumerate}
\item TODO: Describe this
\end{enumerate}
\item \texttt{InitScope getModifierType()}
\begin{enumerate}
\item TODO: Describe this
\end{enumerate}
\end{enumerate}

\subsection{\texttt{Container}}

The \texttt{Container} type is an interface that specifies a certain
type to implement a set of methods. These methods allow the type to
\emph{become} a container by then allowing one or more instances of
\texttt{Statement} or rather a \texttt{Statement[]} to be contained
within the container i.e. making it contain them.\\
\\
It should be noted that the parenting method is used to climb up the
hierachy \textbf{given} a Statement instance, however the Container
technique is useful for a top-down search for an Entity - they are
independent in that sense but can be used toghether .

\section{How to parse}

The basic flow of the parser involves the following process:
\begin{enumerate}
\item Firstly you need an entry point, this entry point for us is the \texttt{parse()}
method which will return an instance of \texttt{Module} which represents
the module - the TLang program.
\item Every \texttt{parseX()} method gets called by another such method
dependent on the current symbol (and sometimes a lookahead)
\begin{enumerate}
\item For example, sometimes when we come across \texttt{SymbolType.IDENTIFIER}
we call \texttt{parseName()} which can then either call \texttt{parseFuncCall()},
\texttt{parseTypedDeclaration()} or \texttt{parseAssignment()}.
This requires a lookahead to check what follows the identifier because
just by itself it is too ambuguous grammatically.
\item After determining what comes next the token is pushed back using \texttt{previousToken()}
and then we proceed into the correct function
\item Lookaheads are rare but they do appear in situations like that
\end{enumerate}
\item The \texttt{parseX()} methods return instances of \texttt{Statement}
which is the top type for all parser-generated nodes or \emph{AST
nodes}.
\item When you are about to parse a sub-section (like an if statement) of
a bigger syntax group (like a body) you leave the \emph{offending
token} as the current token, then you call the parsing method (in
this case \texttt{parseIf()}) and let it handle the call to \texttt{nextToken()}
- this is simply the structure of parsing that TLang follows.
\item Upon exiting a \texttt{parseX()} method you call \texttt{nextToken()}
- this determines whether this method would continue parsing or not
- if not then you return and the caller will continue with that current
token and move on from there.
\end{enumerate}

\subsection{Example of parsing if-statements}

We will now look at an example of how we deal with parsing if statements
in our parser, specifically within the \texttt{parseBody()}. The
beginning of this method starts by moving us off the offending token
that made us call \texttt{parseBody()} (hence the call to \texttt{nextToken()}).
After which we setup an array of \texttt{Statement} such that we
can build up a \emph{body} of them:\begin{lstlisting}[language=Java]
gprintln("parseBody(): Enter", DebugType.WARNING);

Statement[] statements;

/* Consume the `{` symbol */
nextToken();
\end{lstlisting}~\\
Now we are within the body, as you can imagine a body is to be made
up of several statements of which we do not know how many there are.
Therefore we setup a loop that will iterate till we run out of tokens:\begin{lstlisting}[language=Java]
while (hasTokens())
{
	...
}
\end{lstlisting}~\\
Next thing we want to do if grab the current token and check what
type of symbol it is:\begin{lstlisting}[language=Java]
while (hasTokens())
{
	/* Get the token */
	Token tok = getCurrentToken();
	SymbolType symbol = getSymbolType(tok);
	gprintln("parseBody(): SymbolType=" ~ to!(string)(symbol));

	...
}
\end{lstlisting}~\\
Following this we now have several checks that make use of \texttt{getSymbolType(Token)}
in order to determine what the token's type is and then in our case
if the token is \texttt{"if"} then we will make a call to \texttt{parseIf()}
and append the returned Statement-sub-type to the body of statements
(\texttt{Statement[]}):\begin{lstlisting}[language=Java]
while(hasTokens())
{
	...

	/* If it is a branch */
	else if (symbol == SymbolType.IF)
	{
		statements ~= parseIf();
	}

	...
}
\end{lstlisting}
