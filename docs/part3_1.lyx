#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Lexical analysis
\end_layout

\begin_layout Standard
Lexical analysis is the process of taking a program as an input string 
\begin_inset Formula $A$
\end_inset

 and splitting it into a list of 
\begin_inset Formula $n$
\end_inset

 sub-strings 
\begin_inset Formula $A_{1},\,A_{2}\ldots A_{n}$
\end_inset

 called 
\emph on
tokens
\emph default
.
 The length 
\begin_inset Formula $n$
\end_inset

 of this list of dependent on several rules that determine how, when and
 where new tokens are built - this set of rules is called a 
\emph on
grammar
\emph default
.
\end_layout

\begin_layout Section
Grammar
\end_layout

\begin_layout Standard
The Tristan grammar is specified in EBNF below:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

TODO: We need to derive a grammar/come up with one (and include explanations
 of EBNF).
\end_layout

\begin_layout Section
Overview of implementation
\end_layout

\begin_layout Standard
The source code for the lexical analysis part of the compiler is located
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{source/tlang/lexer.d}
\end_layout

\end_inset

 which contains two important class definitions:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token}
\end_layout

\end_inset

 - This represents a token
\end_layout

\begin_deeper
\begin_layout Itemize
Complete with the token string itself, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{token}
\end_layout

\end_inset

.
 Retrivebale with a call to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{getToken()}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The coordinates in the source code where the token begins as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{line}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{column}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Overrides equality (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{opEquals}
\end_layout

\end_inset

) such that doing,
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C]
\end_layout

\begin_layout Plain Layout

new Token(
\begin_inset Quotes eld
\end_inset

int
\begin_inset Quotes erd
\end_inset

) == new Token(
\begin_inset Quotes eld
\end_inset

int
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
would evaluate to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

, rather than false by reference equality (the default in D)
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Lexer}
\end_layout

\end_inset

 - The token builder
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{sourceCode}
\end_layout

\end_inset

, the whole input program (as a string) to be tokenized
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{position}
\end_layout

\end_inset

, holds the index to the current character in the string array 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{sourceCode}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentChar}
\end_layout

\end_inset

, the current character at index-
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{position}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Contains a list of the currently built tokens, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token[] tokens}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Current line and column numbers as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{line}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{column}
\end_layout

\end_inset

 respectively
\end_layout

\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

build up
\begin_inset Quotes erd
\end_inset

 - this is the token (in string form) currently being built - 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentToken}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The implementation of the lexer, the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Lexer}
\end_layout

\end_inset

 class, is explained in detail in this section.
 (TODO: constructor) The lexical analysis is done one-shot via the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{performLex()}
\end_layout

\end_inset

 method which will attempt to tokenize the input program, on failure returning
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 otherwise.
 In the successful case the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{tokens}
\end_layout

\end_inset

 array will be filled with the created tokens and can then later be retrieved
 via a call to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{getTokens()}
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Example usage:
\begin_inset Newline newline
\end_inset

TODO
\end_layout

\begin_layout Subsection
performLex()
\end_layout

\begin_layout Standard
TODO: This is going to change sometime soonish, so I want the final version
 of how it works here.
 I may as well, however, give a brief explanation as I doubt 
\emph on
much 
\emph default
will change - only specific parsing cases.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

This method contains a looping structure which will read character-by-character
 from the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{sourceCode}
\end_layout

\end_inset

 string and follow the rules of the grammar (TODO: add link), looping whilst
 there are still characters available for consumption (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{position < sourceCode.length}
\end_layout

\end_inset

).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

We loop through each character and dependent on its value we start building
 new tokens, certain characters will cause a token to finish being built
 which will sometimes be caused by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{isSpliter(character)}
\end_layout

\end_inset

 being 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

.
 A typical token building process looks something like the following, containing
 the final character to be tacked onto the current token build up, the creation
 of a new token object and the addition of it to the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{tokens}
\end_layout

\end_inset

 list, finishing with flushing the build up string and incrementing the
 coordinates:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

A typical token building procedure looks something like this:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Java]
\end_layout

\begin_layout Plain Layout

/* Generate and add the token */
\end_layout

\begin_layout Plain Layout

currentToken ~= 
\begin_inset Quotes eld
\end_inset

'
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

currentTokens ~= new Token(currentToken, line, column);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Flush the token */
\end_layout

\begin_layout Plain Layout

currentToken = "";
\end_layout

\begin_layout Plain Layout

column += 2
\end_layout

\begin_layout Plain Layout

position += 2;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Character and token availability
\end_layout

\begin_layout Standard
Helper functions relating to character and token availability.
\end_layout

\begin_layout Subsubsection
hasToken()
\end_layout

\begin_layout Standard
Returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 if there is a token currently built i.e.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentToken.length != 0}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

 otherwise.
\end_layout

\begin_layout Subsubsection
isBackward()
\end_layout

\begin_layout Standard
Returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 if we can move the character pointer backwards, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

 otherwise.
\end_layout

\begin_layout Subsubsection
isForward()
\end_layout

\begin_layout Standard
Returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 if we can move the character pointer forward, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

 otherwise.
\end_layout

\begin_layout Subsection
isNumericalStr()
\end_layout

\begin_layout Standard
This method is called in order to chck if the build up, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentToken}
\end_layout

\end_inset

, is a valid numerical string.
 If the string is empty, then it returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

.
 If the string is non-empty and contains anything 
\emph on
other 
\emph default
than digits then it returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

, otherwise is returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection
isSpliter()
\end_layout

\begin_layout Standard
This method checks if the given character is one of the following:
\end_layout

\begin_layout Itemize
character == ';' || character == ',' || character == '(' || character ==
 ')' || character == '[' || character == ']' || character == '+' || character
 == '-' || character == '/' || character == '%' || character == '*' || character
 == '&' || character == '{' || character == '}' || character == '=' || character
 == '|' || character == '^' || character == '!' || character == '
\backslash
n' || character == '~' || character =='.' || character == ':'; 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{;}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{,}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{(}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{[}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{]}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{+}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{-}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{/}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
%}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{*}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
&}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
{}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{=}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

| (TODO: make it texttt)
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
^}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{!}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash

\backslash
n}
\end_layout

\end_inset

(TODO: 
\backslash
n not appearing)
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
~}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{.}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
:}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whenever this method returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 it generally means you should flush the current token, start a new token
 add the offending spliter token and flush that as well.
\end_layout

\end_body
\end_document
