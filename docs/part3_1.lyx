#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Lexical analysis
\end_layout

\begin_layout Standard
Lexical analysis is the process of taking a program as an input string 
\begin_inset Formula $A$
\end_inset

 and splitting it into a list of 
\begin_inset Formula $n$
\end_inset

 sub-strings 
\begin_inset Formula $A_{1},\,A_{2}\ldots A_{n}$
\end_inset

 called 
\emph on
tokens
\emph default
.
 The length 
\begin_inset Formula $n$
\end_inset

 of this list of dependent on several rules that determine how, when and
 where new tokens are built - this set of rules is called a 
\emph on
grammar
\emph default
.
\end_layout

\begin_layout Section
Grammar
\end_layout

\begin_layout Standard
The Tristan grammar is specified in EBNF below:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

TODO: We need to derive a grammar/come up with one (and include explanations
 of EBNF).
\end_layout

\begin_layout Section
Overview of implementation
\end_layout

\begin_layout Standard
The source code for the lexical analysis part of the compiler is located
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{source/tlang/lexer.d}
\end_layout

\end_inset

 which contains two important class definitions:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token}
\end_layout

\end_inset

 - This represents a token
\end_layout

\begin_deeper
\begin_layout Itemize
Complete with the token string itself, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{token}
\end_layout

\end_inset

.
 Retrivebale with a call to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{getToken()}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The coordinates in the source code where the token begins as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{line}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{column}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Overrides equality (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{opEquals}
\end_layout

\end_inset

) such that doing,
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C]
\end_layout

\begin_layout Plain Layout

new Token(
\begin_inset Quotes eld
\end_inset

int
\begin_inset Quotes erd
\end_inset

) == new Token(
\begin_inset Quotes eld
\end_inset

int
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
would evaluate to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

, rather than false by reference equality (the default in D)
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Lexer}
\end_layout

\end_inset

 - The token builder
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{sourceCode}
\end_layout

\end_inset

, the whole input program (as a string) to be tokenized
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{position}
\end_layout

\end_inset

, holds the index to the current character in the string array 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{sourceCode}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentChar}
\end_layout

\end_inset

, the current character at index-
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{position}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Contains a list of the currently built tokens, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token[] tokens}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Current line and column numbers as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{line}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{column}
\end_layout

\end_inset

 respectively
\end_layout

\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

build up
\begin_inset Quotes erd
\end_inset

 - this is the token (in string form) currently being built - 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentToken}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The implementation of the lexer, the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Lexer}
\end_layout

\end_inset

 class, is explained in detail in this section.
 (TODO: constructor) The lexical analysis is done one-shot via the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{performLex()}
\end_layout

\end_inset

 method which will attempt to tokenize the input program, on failure returning
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 otherwise.
 In the successful case the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{tokens}
\end_layout

\end_inset

 array will be filled with the created tokens and can then later be retrieved
 via a call to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{getTokens()}
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Example usage:
\begin_inset Newline newline
\end_inset

TODO
\end_layout

\begin_layout Subsection
performLex()
\end_layout

\begin_layout Standard
TODO: This is going to change sometime soonish, so I want the final version
 of how it works here.
 I may as well, however, give a brief explanation as I doubt 
\emph on
much 
\emph default
will change - only specific parsing cases.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

This method contains a looping structure which will read character-by-character
 from the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{sourceCode}
\end_layout

\end_inset

 string and follow the rules of the grammar (TODO: add link), looping whilst
 there are still characters available for consumption (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{position < sourceCode.length}
\end_layout

\end_inset

).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

We loop through each character and dependent on its value we start building
 new tokens, certain characters will cause a token to finish being built
 which will sometimes be caused by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{isSpliter(character)}
\end_layout

\end_inset

 being 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

.
 A typical token building process looks something like the following, containing
 the final character to be tacked onto the current token build up, the creation
 of a new token object and the addition of it to the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{tokens}
\end_layout

\end_inset

 list, finishing with flushing the build up string and incrementing the
 coordinates:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

A typical token building procedure looks something like this:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Java]
\end_layout

\begin_layout Plain Layout

/* Generate and add the token */
\end_layout

\begin_layout Plain Layout

currentToken ~= 
\begin_inset Quotes eld
\end_inset

'
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

currentTokens ~= new Token(currentToken, line, column);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Flush the token */
\end_layout

\begin_layout Plain Layout

currentToken = "";
\end_layout

\begin_layout Plain Layout

column += 2
\end_layout

\begin_layout Plain Layout

position += 2;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Character and token availability
\end_layout

\begin_layout Standard
Helper functions relating to character and token availability.
\end_layout

\begin_layout Subsubsection
hasToken()
\end_layout

\begin_layout Standard
Returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 if there is a token currently built i.e.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentToken.length != 0}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

 otherwise.
\end_layout

\begin_layout Subsubsection
isBackward()
\end_layout

\begin_layout Standard
Returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 if we can move the character pointer backwards, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

 otherwise.
\end_layout

\begin_layout Subsubsection
isForward()
\end_layout

\begin_layout Standard
Returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 if we can move the character pointer forward, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

 otherwise.
\end_layout

\begin_layout Subsection
isNumericalStr()
\end_layout

\begin_layout Standard
This method is called in order to chck if the build up, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentToken}
\end_layout

\end_inset

, is a valid numerical string.
 If the string is empty, then it returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

.
 If the string is non-empty and contains anything 
\emph on
other 
\emph default
than digits then it returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

, otherwise is returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection
isSpliter()
\end_layout

\begin_layout Standard
This method checks if the given character is one of the following:
\end_layout

\begin_layout Itemize
character == ';' || character == ',' || character == '(' || character ==
 ')' || character == '[' || character == ']' || character == '+' || character
 == '-' || character == '/' || character == '%' || character == '*' || character
 == '&' || character == '{' || character == '}' || character == '=' || character
 == '|' || character == '^' || character == '!' || character == '
\backslash
n' || character == '~' || character =='.' || character == ':'; 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{;}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{,}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{(}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{[}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{]}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{+}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{-}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{/}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
%}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{*}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
&}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
{}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{=}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

| (TODO: make it texttt)
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
^}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{!}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash

\backslash
n}
\end_layout

\end_inset

(TODO: 
\backslash
n not appearing)
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
~}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{.}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
:}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whenever this method returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 it generally means you should flush the current token, start a new token
 add the offending spliter token and flush that as well.
\end_layout

\begin_layout Chapter
Code emit
\end_layout

\begin_layout Standard
The code emit process is the final process of the compiler whereby the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{initQueue}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{codeQueue}
\end_layout

\end_inset

 and all assorted auxilllary information is passed to an instance of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{CodeEmitter}
\end_layout

\end_inset

 (in the case of the C backend this is sub-typed to the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{DGen}
\end_layout

\end_inset

 class) such that the code can be written to a file.
 At this stage all queues consist simpyl of instances of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Instruction}
\end_layout

\end_inset

 class.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Our C backend or 
\emph on
custom code emitter
\emph default
, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{DGen}
\end_layout

\end_inset

, inherits from the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{CodeEmitter}
\end_layout

\end_inset

 class which specifies that the following methods must be overriden/implemented:
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{emit()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Begins the emit process
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{finalize()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Finalizes the emitting process (only to be called after the `emit()` finishes)
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{transform(Instruction instruction)}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Transforms or emits a single Instruction and returns the transformation
 as a string
\end_layout

\end_deeper
\begin_layout Section
Custom code emits
\end_layout

\begin_layout Standard
We override/implement the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{transform(Instruction instruction)}
\end_layout

\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{DGen}
\end_layout

\end_inset

 to work somewhat as a big if-statement that matches the different sub-types
 of Instructions that exist, then the respective code-emit (C code) is generated.
 This method has the potential to be recursive as some instructions contain
 nested instructions that must be transformed prior before the final transformat
ion, in which case a recursive call to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{transform(Instruction)}
\end_layout

\end_inset

 is made.
\end_layout

\begin_layout Subsection
Code emit example: Variable declarations
\end_layout

\begin_layout Standard
For example, with the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{VariableDeclaration}
\end_layout

\end_inset

 instruction we have such an emit which fetches the type of the variable
 being declared and its name, then concatenates these toghether with spaces
 and a trailing semi-colon:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Java]
\end_layout

\begin_layout Plain Layout

/* VariableDeclaration */
\end_layout

\begin_layout Plain Layout

else if(cast(VariableDeclaration)instruction)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	VariableDeclaration varDecInstr = cast(VariableDeclaration)instruction;
\end_layout

\begin_layout Plain Layout

	Context context = varDecInstr.getContext();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	auto typedEntityVariable = context.tc.getResolver().resolveBest(context.getContaine
r(), varDecInstr.varName); //TODO: Remove `auto`
\end_layout

\begin_layout Plain Layout

	string typedEntityVariableName = context.tc.getResolver().generateName(context.getC
ontainer(), typedEntityVariable); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//NOTE: We should remove all dots from generated symbol names as it won't
 be valid C (I don't want to say C because
\end_layout

\begin_layout Plain Layout

	// a custom CodeEmitter should be allowed, so let's call it a general rule)
\end_layout

\begin_layout Plain Layout

	//
\end_layout

\begin_layout Plain Layout

	//simple_variables.x -> simple_variables_x
\end_layout

\begin_layout Plain Layout

	//NOTE: We may need to create a symbol table actually and add to that and
 use that as these names             	//could get out of hand (too long)
\end_layout

\begin_layout Plain Layout

	// NOTE: Best would be identity-mapping Entity's to a name
\end_layout

\begin_layout Plain Layout

	import compiler.codegen.mapper : SymbolMapper;
\end_layout

\begin_layout Plain Layout

	string renamedSymbol = SymbolMapper.symbolLookup(context.getContainer(),
 varDecInstr.varName);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return varDecInstr.varType~" "~renamedSymbol~";";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Symbol renaming
\end_layout

\begin_layout Standard
Of the many sub-types of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Instruction}
\end_layout

\end_inset

 class, when it comes to time to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{emit()}
\end_layout

\end_inset

 some code we do need to apply certain fixups to some of the symbol names
 (if any) which will appear in the final emitted code.
 Nmaely, we need to remove any periods in the name such that something like
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{simple
\backslash
_variables.x}
\end_layout

\end_inset

 becomes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{simple
\backslash
_variables
\backslash
_x}
\end_layout

\end_inset

.
 The reason for this is because when we emit C code using the DGen code
 emitter we will need to have valid C names which cannot contain characters
 such as periods.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The method used in order to do this is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{symbolRename()}
\end_layout

\end_inset

 from the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{mics.utils}
\end_layout

\end_inset

 module which takes in the symbol name and returns the 
\emph on

\begin_inset Quotes eld
\end_inset

fixed-up
\begin_inset Quotes erd
\end_inset


\emph default
 version.
\end_layout

\end_body
\end_document
