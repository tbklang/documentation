#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Lexical analysis
\end_layout

\begin_layout Standard
Lexical analysis is the process of taking a program as an input string 
\begin_inset Formula $A$
\end_inset

 and splitting it into a list of 
\begin_inset Formula $n$
\end_inset

 sub-strings 
\begin_inset Formula $A_{1},\,A_{2}\ldots A_{n}$
\end_inset

 called 
\emph on
tokens
\emph default
.
 The length 
\begin_inset Formula $n$
\end_inset

 of this list of dependent on several rules that determine how, when and
 where new tokens are built - this set of rules is called a 
\emph on
grammar
\emph default
.
\end_layout

\begin_layout Section
Grammar
\end_layout

\begin_layout Standard
The Tristan grammar is specified in EBNF below:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

TODO: We need to derive a grammar/come up with one (and include explanations
 of EBNF).
\end_layout

\begin_layout Section
Overview of implementation
\end_layout

\begin_layout Standard
The source code for the lexical analysis part of the compiler is located
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{source/tlang/lexer.d}
\end_layout

\end_inset

 which contains two important class definitions:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token}
\end_layout

\end_inset

 - This represents a token
\end_layout

\begin_deeper
\begin_layout Itemize
Complete with the token string itself, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{token}
\end_layout

\end_inset

.
 Retrivebale with a call to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{getToken()}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The coordinates in the source code where the token begins as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{line}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{column}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Overrides equality (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{opEquals}
\end_layout

\end_inset

) such that doing,
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C]
\end_layout

\begin_layout Plain Layout

new Token(
\begin_inset Quotes eld
\end_inset

int
\begin_inset Quotes erd
\end_inset

) == new Token(
\begin_inset Quotes eld
\end_inset

int
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
would evaluate to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

, rather than false by reference equality (the default in D)
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Lexer}
\end_layout

\end_inset

 - The token builder
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{sourceCode}
\end_layout

\end_inset

, the whole input program (as a string) to be tokenized
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{position}
\end_layout

\end_inset

, holds the index to the current character in the string array 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{sourceCode}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentChar}
\end_layout

\end_inset

, the current character at index-
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{position}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Contains a list of the currently built tokens, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Token[] tokens}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Current line and column numbers as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{line}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{column}
\end_layout

\end_inset

 respectively
\end_layout

\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

build up
\begin_inset Quotes erd
\end_inset

 - this is the token (in string form) currently being built - 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentToken}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The implementation of the lexer, the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Lexer}
\end_layout

\end_inset

 class, is explained in detail in this section.
 (TODO: constructor) The lexical analysis is done one-shot via the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{performLex()}
\end_layout

\end_inset

 method which will attempt to tokenize the input program, on failure returning
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 otherwise.
 In the successful case the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{tokens}
\end_layout

\end_inset

 array will be filled with the created tokens and can then later be retrieved
 via a call to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{getTokens()}
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Example usage:
\begin_inset Newline newline
\end_inset

TODO
\end_layout

\begin_layout Subsection
performLex()
\end_layout

\begin_layout Standard
TODO: This is going to change sometime soonish, so I want the final version
 of how it works here.
 I may as well, however, give a brief explanation as I doubt 
\emph on
much 
\emph default
will change - only specific parsing cases.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

This method contains a looping structure which will read character-by-character
 from the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{sourceCode}
\end_layout

\end_inset

 string and follow the rules of the grammar (TODO: add link), looping whilst
 there are still characters available for consumption (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{position < sourceCode.length}
\end_layout

\end_inset

).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

We loop through each character and dependent on its value we start building
 new tokens, certain characters will cause a token to finish being built
 which will sometimes be caused by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{isSpliter(character)}
\end_layout

\end_inset

 being 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

.
 A typical token building process looks something like the following, containing
 the final character to be tacked onto the current token build up, the creation
 of a new token object and the addition of it to the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{tokens}
\end_layout

\end_inset

 list, finishing with flushing the build up string and incrementing the
 coordinates:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

A typical token building procedure looks something like this:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Java]
\end_layout

\begin_layout Plain Layout

/* Generate and add the token */
\end_layout

\begin_layout Plain Layout

currentToken ~= 
\begin_inset Quotes eld
\end_inset

'
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

currentTokens ~= new Token(currentToken, line, column);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Flush the token */
\end_layout

\begin_layout Plain Layout

currentToken = "";
\end_layout

\begin_layout Plain Layout

column += 2
\end_layout

\begin_layout Plain Layout

position += 2;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Character and token availability
\end_layout

\begin_layout Standard
Helper functions relating to character and token availability.
\end_layout

\begin_layout Subsubsection
hasToken()
\end_layout

\begin_layout Standard
Returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 if there is a token currently built i.e.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentToken.length != 0}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

 otherwise.
\end_layout

\begin_layout Subsubsection
isBackward()
\end_layout

\begin_layout Standard
Returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 if we can move the character pointer backwards, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

 otherwise.
\end_layout

\begin_layout Subsubsection
isForward()
\end_layout

\begin_layout Standard
Returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 if we can move the character pointer forward, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

 otherwise.
\end_layout

\begin_layout Subsection
isNumericalStr()
\end_layout

\begin_layout Standard
This method is called in order to chck if the build up, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{currentToken}
\end_layout

\end_inset

, is a valid numerical string.
 If the string is empty, then it returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

.
 If the string is non-empty and contains anything 
\emph on
other 
\emph default
than digits then it returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{false}
\end_layout

\end_inset

, otherwise is returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection
isSpliter()
\end_layout

\begin_layout Standard
This method checks if the given character is one of the following:
\end_layout

\begin_layout Itemize
character == ';' || character == ',' || character == '(' || character ==
 ')' || character == '[' || character == ']' || character == '+' || character
 == '-' || character == '/' || character == '%' || character == '*' || character
 == '&' || character == '{' || character == '}' || character == '=' || character
 == '|' || character == '^' || character == '!' || character == '
\backslash
n' || character == '~' || character =='.' || character == ':'; 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{;}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{,}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{(}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{[}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{]}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{+}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{-}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{/}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
%}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{*}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
&}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
{}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{=}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

| (TODO: make it texttt)
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
^}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{!}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash

\backslash
n}
\end_layout

\end_inset

(TODO: 
\backslash
n not appearing)
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
~}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{.}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{
\backslash
:}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whenever this method returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{true}
\end_layout

\end_inset

 it generally means you should flush the current token, start a new token
 add the offending spliter token and flush that as well.
\end_layout

\begin_layout Chapter
Code emit
\end_layout

\begin_layout Standard
The code emit process is the final process of the compiler whereby the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{initQueue}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{codeQueue}
\end_layout

\end_inset

 and all assorted auxilllary information is passed to an instance of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{CodeEmitter}
\end_layout

\end_inset

 (in the case of the C backend this is sub-typed to the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{DGen}
\end_layout

\end_inset

 class) such that the code can be written to a file.
 At this stage all queues consist simply of instances of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Instruction}
\end_layout

\end_inset

 class.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Our C backend or 
\emph on
custom code emitter
\emph default
, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{DGen}
\end_layout

\end_inset

, inherits from the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{CodeEmitter}
\end_layout

\end_inset

 class which specifies that the following methods must be overriden/implemented:
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{emit()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Begins the emit process
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{finalize()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Finalizes the emitting process (only to be called after the `emit()` finishes)
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{transform(Instruction instruction)}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Transforms or emits a single Instruction and returns the transformation
 as a string
\end_layout

\end_deeper
\begin_layout Section
Queues
\end_layout

\begin_layout Standard
There are several notable queues that the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{CodeEmitter}
\end_layout

\end_inset

 class contains, these are as follows:
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{initQueue}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Despite its name this holds instructions for doing memory allocations for
 static entities (
\series bold
not
\series default
 initialization code for said entities)
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{globalsQueue}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
This queue holds instructions for the globals executions.
 This includes things such as global variable declarations and the sorts.
\end_layout

\end_deeper
\begin_layout Enumerate
Function definitions map
\end_layout

\begin_deeper
\begin_layout Enumerate
This is a string-to-queue map which contains the code queues for every function
 definition.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Along with these queues there are some methods used to amniopulate and use
 them, these are:
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{selectQueue(QueueType, string)}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Select the type of queue: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{ALLOC
\backslash
_QUEUE}
\end_layout

\end_inset

 (for the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{initQueue}
\end_layout

\end_inset

), 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{GLOBALS
\backslash
_QUEUE}
\end_layout

\end_inset

 (for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{globalsQueue}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{FUNCTION
\backslash
_DEF
\backslash
_QUEUE}
\end_layout

\end_inset

 (for the function definitions queue)
\end_layout

\begin_layout Enumerate
For function definitions, the optional string argument (second argument)
 must specify the name of the function definition you would wish to use.
 An invalid name will throw an error.
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Ensure we do this actually
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
This automatically calls 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{resetCursor()}
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{nextInstruction()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Moves the cursor to the next instruction.
 Throws an exception if out of bounds.
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Ensure we do this actually
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{previousInstruction()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Moves the cursor to the previous instruction.
 Throws an exception if out of bounds.
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Ensure we do this actually
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{resetCursor()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Resets the position of the instruction pointer to 0.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{getCurrentInstruction()}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Retrieves the current instruction at the cursor.
\end_layout

\end_deeper
\begin_layout Section
Custom code emits
\end_layout

\begin_layout Standard
We override/implement the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{transform(Instruction instruction)}
\end_layout

\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{DGen}
\end_layout

\end_inset

 to work somewhat as a big if-statement that matches the different sub-types
 of Instructions that exist, then the respective code-emit (C code) is generated.
 This method has the potential to be recursive as some instructions contain
 nested instructions that must be transformed prior before the final transformat
ion, in which case a recursive call to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{transform(Instruction)}
\end_layout

\end_inset

 is made.
\end_layout

\begin_layout Subsection
Code emit example: Variable declarations
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Update this with new symbol mapper code
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The example below is the code used to transform the in-memory representation
 of a variable declaration, known as the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{VariableDeclaration}
\end_layout

\end_inset

 instruction, into the C code to be emitted:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Java]
\end_layout

\begin_layout Plain Layout

/* VariableDeclaration */
\end_layout

\begin_layout Plain Layout

else if(cast(VariableDeclaration)instruction)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	VariableDeclaration varDecInstr = cast(VariableDeclaration)instruction;
\end_layout

\begin_layout Plain Layout

	Context context = varDecInstr.getContext();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	Variable typedEntityVariable = cast(Variable)context.tc.getResolver().resolveBest(
context.getContainer(), varDecInstr.varName);
\end_layout

\begin_layout Plain Layout

	string typedEntityVariableName = context.tc.getResolver().generateName(context.getC
ontainer(), typedEntityVariable); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	string renamedSymbol = SymbolMapper.symbolLookup(context.getContainer(),
 varDecInstr.varName);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return varDecInstr.varType~" "~renamedSymbol~";";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

What we have here is some code which will extract the name of the variable
 being declared via 
\backslash
texttt{varDecInstr.varName} which is then used to lookup the parser node
 of type 
\backslash
texttt{Variable}.
 The 
\backslash
texttt{Variable} object contains information such as the variable's type
 and also if a variable assignment is attached to this declaration or not.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

TODO: Insert code regarding assignment checking
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Right at the end wwe then build up the C variable declaration with the line:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Java]
\end_layout

\begin_layout Plain Layout

return varDecInstr.varType~" "~renamedSymbol~";";
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Symbol renaming
\end_layout

\begin_layout Standard
In terms of general code emitting we could have simply decided to use the
 TLang-esque symbol name structure where entities are seperated by periods
 such as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{simple
\backslash
_module.x}
\end_layout

\end_inset

 where 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{simple
\backslash
_module}
\end_layout

\end_inset

 is a container-type such as a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{module}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{x}
\end_layout

\end_inset

 is some entity within it, such as a variable.
 However, what we have decided to do in the emitter process, specifically
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{DGen}
\end_layout

\end_inset

 - our C code emitter - is to actually rename these symbols to a hash, wherever
 they occur.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The renaming mechanism is hanlded by the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{symbolLookup(container, entityName)}
\end_layout

\end_inset

 method from the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{SymbolMapper}
\end_layout

\end_inset

 class.
 This takes in two arguments:
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{container}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
This must be a type-of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Container}
\end_layout

\end_inset

 such that the provided entity name is looked up relative to it
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{entityName}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
This is the name of the entity to look up relative to the container
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

This allows one do then translate the symbol name with the following usage.
 In this case we want to translate the symbol of the entity named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{x}
\end_layout

\end_inset

 which is container in the module-container named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{simple
\backslash
_variables
\backslash
_decls
\backslash
_ass}
\end_layout

\end_inset

.
 Therefore we provide both peices of information into the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{symbolLookup}
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Java]
\end_layout

\begin_layout Plain Layout

// The relative container of this variable is the module
\end_layout

\begin_layout Plain Layout

Container container = tc.getModule();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// The name of the variable
\end_layout

\begin_layout Plain Layout

string name = 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Symbol map
\end_layout

\begin_layout Plain Layout

string renamedSymbol = SymbolMapper.symbolLookup(container, name);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// renamedSymbol == t_c326f89096616e69e89a3874a4c7f324
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

The resulting hash is generated by resolving the absolute path name of the
 entity provided, applying an md5 hash to this name and then pre-pending
 a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{t
\backslash
_}
\end_layout

\end_inset

 to the name.
 Therefore for the above code we will have 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{simple
\backslash
_variables
\backslash
_decls
\backslash
_ass.x}
\end_layout

\end_inset

 mapped to a symbol name of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{t
\backslash
_c326f89096616e69e89a3874a4c7f324}
\end_layout

\end_inset

 to be emitted into the C code file.
\end_layout

\end_body
\end_document
